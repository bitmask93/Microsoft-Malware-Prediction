# Microsoft Malware Prediction

## Objective :
Objective is to predict a Windows machineâ€™s probability of getting infected by various families of malware, based on different properties of that machine. This is a binary Classification Problem.

## Dataset :
Each row in this dataset corresponds to a machine, uniquely identified by a MachineIdentifier. HasDetections is the ground truth and indicates that Malware was detected on the machine. Using the information and labels in train.csv, you must predict the value for HasDetections for each machine in test.csv.

The Dataset can be downloaded from Kaggle :  [Link](https://www.kaggle.com/c/microsoft-malware-prediction/data) 

## Performance Metric :

Submissions are evaluated on area under the ROC curve between the predicted probability and the observed label. Here we are using AUC_ROC curve because in this case, we care about both the classes equally. Besides, the dataset is Balanced as well.

## EDA and Data Cleaning :

The Train Dataset is huge ~4GB and if we try to load the entire dataset as it is, it will lead to memory error. So we need to reduce the memory size by doing the following :
- Convert objects into categories

- 64 bits encoding are all switched to 32, or 16.

- Binary values are switched to int8

- Binary values with missing values are switched to float16 (int does not understand nan) 

**Handling Missing Values :**  The dataset consists of many missing values, so I removed those features which consists of high number of missing values. The following features were dropped from the original dataset :

[DefaultBrowsersIdentifier, PuaMode, Census_ProcessorClass, Census_IsFlightingInternal , Census_InternalBatteryType , Census_IsFlightsDisabled , Census_ThresholdOptIn, Census_InternalBatteryNumberOfCharges , Census_IsWIMBootEnabled , ProductName,OrganizationIdentifier]

Now for rest of the missing features : 

- For numerical features  : [Census_InternalPrimaryDiagonalDisplaySizeInInches, Census_PrimaryDiskTotalCapacity, Census_ProcessorCoreCount, Census_SystemVolumeTotalCapacity, Census_TotalPhysicalRAM], missing values were imputed with (-1)

- For the Binary Features : [Census_HasOpticalDiskDrive, Census_IsAlwaysOnAlwaysConnectedCapable, Census_IsPenCapable, Census_IsPortableOperatingSystem, Census_IsSecureBootEnabled, Census_IsTouchEnabled, Census_IsVirtualDevice, Firewall, HasTpm, IsProtected, IsSxsPassiveMode, SMode, Wdft_IsGamer] imputed missing values with  mode of the  feature.

- For Rest of the Categorical Features, imputed missing values with a separate category : "unknown"

**Other Data Cleaning : **

Dropped the features which has msjority of the values dominated by a single value as well as those features which consists of many categories, the following features were dropped :
- [IsBeta, AVProductStatesIdentifier, CityIdentifier, AutoSampleOptIn, SMode, UacLuaenable, Census_DeviceFamily, Census_OEMNameIdentifier, Census_OEMModelIdentifier, Census_ProcessorManufacturerIdentifier, Census_ProcessorModelIdentifier, Census_FirmwareVersionIdentifier]

- Some of the Features had to be corrected manually for spellings, they are : [SmartScreen, Census_MDC2FormFactor_new, Census_ChassisTypeName, Census_OSEdition, Census_OSSkuName, Census_ActivationChannel]

- For an in-depth EDA and Datacleaning, please refer the [Data_Cleaning&EDA.ipynb](https://nbviewer.jupyter.org/github/bitmask93/Microsoft-Malware-Prediction/blob/main/Data_Cleaning%26EDA.ipynb) notebook.

## Feature Engineering :

**Some Basic Features :**

- The feature "EngineVersion" consists of 4 parts eg : 1.1.15100.1, this was split into 4 parts and since 1st and 2nd part consists of only 1, we use the 3rd and 4th part as features.

- The feature "AppVersion"  consists of 4 parts eg : 4.18.1807.18075, we split this into 4 parts and here the first part only consists of 4, so we use the remaining 3 parts as 3 new features.

- The feature "AvSigVersion" consists of 4 parts eg : 1.273.1735.0, so we split this feature into 4 parts and since the first part consists only of 1 and last part consists of only 0, we use the middle 2 parts as new features.

- The feature "OsVer" consists of 4 parts eg : 10.0.0.0, we split this feature into 4 and here the last part is always zero, so we use the first three parts.

- The feature "Census_OSVersion" also consists of 4 parts eg : 10.0.17134.165	, split this feature into 4 parts, here the first part is always 10 and 2nd is always 0, so we use the 3rd and 4th part.

- Apart from this I encoded the categorical values with labelencoding. 

**Additional Features :**

- For some additional features, I took some features from [this](https://www.kaggle.com/c/microsoft-malware-prediction/discussion/84065)

## Models and Results :

- For models I tried with Catboost Classifier. For hyperparameter tuning I used 20% of the whole data and then trained Catboost model on the best parameters, the best parameters obtained are : depth : 7, estimator : 2000 and learn_rate : 0.2 and the roc obtained for these parameters : 0.7159953410107316 on validation data.

- Once I obtained the best parameters, I trained the catboost model on the entire train data and then predicted the results for the test dataset which kaggle has provided.

- For the predictions submitted in Kaggle, I was able to obtain a private score of 0.65549 which would place me in top 1% of all the submissions with an approximate rank of 16/2410. Since this is not an active competition, I could not get the results on the leaderboard, however, I have attached the scoreard from kaggle :

![alt text](https://github.com/bitmask93/Microsoft-Malware-Prediction/blob/main/scorecard.png) 

- The entire Feature Engineering and modeling can be found in the [Feature_Engineering&Modeling.ipynb](https://nbviewer.jupyter.org/github/bitmask93/Microsoft-Malware-Prediction/blob/main/Feature_Engineering%26Modeling.ipynb)

- Overall, I did not try any Complex ensemble models or used leaks and still I was able to get a kaggle score to be within top 1%. 
